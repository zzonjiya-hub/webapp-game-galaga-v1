<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>갤러그 v1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            touch-action: none; /* 터치 스크롤 방지 */
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        canvas {
            background-color: #000;
            display: block;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            width: 100%;
            box-sizing: border-box;
        }
        .score-box { color: #ff0000; }
        .high-score-box { color: #ffff00; }
        
        /* 전체화면 버튼 스타일 */
        #fullscreen-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 20px;
            border-radius: 5px;
            margin-left: 20px;
        }
        #fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border: 2px solid #fff;
            border-radius: 10px;
            width: 80%;
            max-width: 400px;
        }
        button.action-btn {
            background: #f00;
            color: #fff;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-family: inherit;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            font-weight: bold;
            width: 100%;
        }
        button.action-btn:hover {
            background: #d00;
        }
        h1 { margin-top: 0; color: #00ffff; text-shadow: 3px 3px 0 #f00; font-size: 32px;}
        p { font-size: 14px; color: #ccc; line-height: 1.6; }
        .hidden { display: none !important; }
        
        /* 모바일 안내 메시지 */
        .mobile-hint {
            display: none;
            color: #ffff00;
            font-size: 12px;
            margin-top: 10px;
        }
        
        @media (hover: none) and (pointer: coarse) {
            .mobile-hint { display: block; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-layer">
            <div class="header">
                <div>
                    1UP <span id="score" style="color:white">00</span>
                </div>
                <div>
                    <span class="high-score-box">HIGH SCORE <span id="high-score" style="color:white">20000</span></span>
                    <button id="fullscreen-btn" title="전체화면">⛶</button>
                </div>
            </div>
            
            <div id="start-screen">
                <h1>GALAXY DEFENDER</h1>
                <p>PC: 방향키 이동 / SPACE 발사<br>Mobile: 기체를 터치하여 드래그 (자동발사)</p>
                <button id="start-btn" class="action-btn">INSERT COIN (START)</button>
            </div>

            <div id="game-over-screen" class="hidden">
                <h1 style="color:red">GAME OVER</h1>
                <p>FINAL SCORE: <span id="final-score">0</span></p>
                <button id="restart-btn" class="action-btn">TRY AGAIN</button>
            </div>
        </div>
    </div>

<script>
/**
 * Sound Manager (Web Audio API)
 */
 const SoundManager = {
    ctx: null,
    
    init: function() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!this.ctx && AudioContext) {
            this.ctx = new AudioContext();
        }
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },

    // 총알 발사음: 볼륨을 절반으로 줄임
    playShoot: function() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.type = 'square';
        osc.frequency.setValueAtTime(880, t);
        osc.frequency.exponentialRampToValueAtTime(110, t + 0.15);

        // 기존 0.05에서 0.025로 수정 (볼륨 50%)
        gain.gain.setValueAtTime(0.025, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

        osc.start(t);
        osc.stop(t + 0.15);
    },

    // 폭발음: 묵직한 타격감 추가
    playExplosion: function() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        
        // 1. 노이즈 (기존 폭발음 - 고음역 파열음)
        const bufferSize = this.ctx.sampleRate * 0.4; // 길이 약간 증가
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'lowpass';
        noiseFilter.frequency.setValueAtTime(1000, t);
        noiseFilter.frequency.exponentialRampToValueAtTime(50, t + 0.3); // 필터가 더 빠르게 닫힘

        const noiseGain = this.ctx.createGain();
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(this.ctx.destination);

        noiseGain.gain.setValueAtTime(0.3, t); // 볼륨 살짝 증가
        noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

        noise.start(t);
        noise.stop(t + 0.4);

        // 2. 킥/저음 (새로 추가 - 묵직한 폭발 느낌)
        const osc = this.ctx.createOscillator();
        const oscGain = this.ctx.createGain();
        
        osc.connect(oscGain);
        oscGain.connect(this.ctx.destination);

        osc.type = 'triangle'; // 둥근 저음
        osc.frequency.setValueAtTime(150, t); // 150Hz에서 시작
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.3); // 40Hz로 떨어짐 (쿵!)

        oscGain.gain.setValueAtTime(0.5, t);
        oscGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

        osc.start(t);
        osc.stop(t + 0.4);
    },

    playStart: function() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.type = 'sine';
        osc.frequency.setValueAtTime(900, t);
        osc.frequency.setValueAtTime(1800, t + 0.1);

        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0.1, t + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);

        osc.start(t);
        osc.stop(t + 0.6);
    }
};

/**
 * Game Constants & Setup
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highScoreEl = document.getElementById('high-score');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const finalScoreEl = document.getElementById('final-score');
const fullscreenBtn = document.getElementById('fullscreen-btn');

let gameState = {
    running: false,
    score: 0,
    highScore: 20000,
    lives: 5, // 초기 비행기 대수 5대로 설정
    level: 1,
    frames: 0
};

const keys = {
    ArrowLeft: false,
    ArrowRight: false,
    Space: false
};

// 모바일 드래그 상태
let isDragging = false;

let player;
let bullets = [];
let enemyBullets = [];
let enemies = [];
let particles = [];
let stars = [];

/**
 * Utility Functions
 */
function rectCollision(rect1, rect2) {
    return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
    );
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.imageSmoothingEnabled = false;
}

// 전체화면 토글 함수
function toggleFullScreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
        });
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// 전체화면 버튼 리스너
fullscreenBtn.addEventListener('click', toggleFullScreen);

/**
 * Classes
 */

class Star {
    constructor() {
        this.x = Math.random() * canvas.width; 
        this.y = Math.random() * canvas.height; 
        this.speed = Math.random() * 0.5 + 0.1;
        this.size = Math.random() * 1.5 + 0.5;
        this.color = Math.random() > 0.9 ? '#aaf' : '#555';
        if (Math.random() > 0.98) this.color = '#faa';
    }

    update() {
        this.y += (this.speed * (gameState.level * 0.5 + 1)); 
        if (this.y > canvas.height) {
            this.y = 0;
            this.x = Math.random() * canvas.width;
        }
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.life = 30;
        this.color = color;
        this.size = Math.random() * 3 + 1;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.size *= 0.9;
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 30;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

class Player {
    constructor() {
        this.width = 60;
        this.height = 60;
        this.x = canvas.width / 2 - this.width / 2;
        // 수정: 화면 하단에서 비행기 높이의 절반(0.5)만큼 여백을 둠
        // this.y = canvas.height - this.height - margin (margin = 0.5 * height)
        this.y = canvas.height - this.height * 1.5; 
        
        this.speed = 4;
        this.cooldown = 0;
        this.invulnerable = 0;
        this.visible = true;
    }

    update() {
        if (!this.visible) return;

        // 키보드 이동
        if (keys.ArrowLeft && this.x > 10) this.x -= this.speed;
        if (keys.ArrowRight && this.x < canvas.width - this.width - 10) this.x += this.speed;

        // 드래그 시 발사 또는 스페이스바 발사
        if ((keys.Space || isDragging) && this.cooldown <= 0) {
            bullets.push(new Bullet(this.x + this.width / 2 - 3, this.y));
            this.cooldown = 10;
            SoundManager.playShoot();
        }
        if (this.cooldown > 0) this.cooldown--;
        if (this.invulnerable > 0) this.invulnerable--;
    }

    draw() {
        if (!this.visible) return;
        if (this.invulnerable > 0 && Math.floor(gameState.frames / 4) % 2 === 0) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(2, 2);
        
        ctx.fillStyle = "#eee";
        ctx.beginPath();
        ctx.moveTo(15, 0);
        ctx.lineTo(24, 18);
        ctx.lineTo(24, 24);
        ctx.lineTo(6, 24);
        ctx.lineTo(6, 18);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#d00";
        ctx.fillRect(13, 8, 4, 16);
        ctx.fillRect(2, 18, 4, 10);
        ctx.fillRect(24, 18, 4, 10);
        
        if (gameState.frames % 10 < 5) {
            ctx.fillStyle = "#fa0";
            ctx.fillRect(12, 26, 6, 4);
        }

        ctx.restore();
    }
    
    explode() {
        createExplosion(this.x + this.width/2, this.y + this.height/2, "#fff");
        SoundManager.playExplosion();
        this.visible = false;
        this.invulnerable = 180;
        
        // 드래그 상태 초기화
        isDragging = false; 
        
        setTimeout(() => {
            gameState.lives--;
            if(gameState.lives > 0) {
                this.x = canvas.width / 2 - this.width / 2;
                this.visible = true;
            } else {
                endGame();
            }
        }, 1000);
    }
}

// Player Bullet
class Bullet {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 6;
        this.height = 15;
        this.speed = 10;
        this.active = true;
    }

    update() {
        this.y -= this.speed;
        if (this.y < 0) this.active = false;
    }

    draw() {
        ctx.fillStyle = "#ff0";
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.fillStyle = "#fff";
        ctx.fillRect(this.x + 1.5, this.y + 2, 3, 11);
    }
}

// Enemy Bullet
class EnemyBullet {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 12;
        this.height = 12;
        this.speed = 2.5;
        this.active = true;
    }
    
    update() {
        this.y += this.speed;
        if (this.y > canvas.height) this.active = false;
    }
    
    draw() {
        const radius = this.width / 2;
        const cx = this.x + radius;
        const cy = this.y + radius;

        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        
        ctx.fillStyle = "#ff0";
        ctx.fill();
        
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#f00";
        ctx.stroke();
    }
}

class Enemy {
    constructor(x, y, type, gridX, gridY) {
        this.x = x;
        this.y = y;
        this.originX = x;
        this.originY = y;
        this.gridX = gridX;
        this.gridY = gridY;
        this.type = type; // 0: Boss, 1: Red, 2: Blue
        
        this.width = 48;
        this.height = 48;
        
        this.active = true;
        this.state = 'formation';
        this.vx = 0;
        this.vy = 0;
    }

    update() {
        if (this.state === 'formation') {
            const sway = Math.sin(gameState.frames * 0.015) * 60;
            this.x = this.originX + sway;
            
            const diveChance = 0.00005 + (gameState.level * 0.00005) + (this.type * 0.00005);
            if (player.visible && Math.random() < diveChance) {
                this.startDive();
            }
        } else if (this.state === 'diving') {
            this.x += this.vx;
            this.y += this.vy;
            
            if (this.y < canvas.height / 2) {
                 if (this.x < player.x) this.vx += 0.025;
                 else this.vx -= 0.025;
            }

            if (Math.random() < 0.015 && this.y < player.y - 100) {
                 enemyBullets.push(new EnemyBullet(this.x + this.width/2 - 6, this.y + this.height));
            }

            if (this.y > canvas.height + 20) {
                this.y = -60;
                this.state = 'returning';
                this.x = this.originX + (Math.sin(gameState.frames * 0.015) * 60);
                this.vx = 0;
                this.vy = 1.5;
            }
        } else if (this.state === 'returning') {
            const targetX = this.originX + (Math.sin(gameState.frames * 0.015) * 60);
            const targetY = this.originY;
            
            const dx = targetX - this.x;
            const dy = targetY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < 4) {
                this.state = 'formation';
                this.y = targetY;
            } else {
                this.x += (dx / dist) * 2;
                this.y += (dy / dist) * 2;
            }
        }
        
        this.frame = Math.floor(gameState.frames / 40) % 2;
    }
    
    startDive() {
        this.state = 'diving';
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        this.vx = Math.cos(angle) * 1.5; 
        this.vy = Math.sin(angle) * 1.5 + 1;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        
        if (this.state === 'diving') {
            ctx.scale(2, -2);
        } else {
            ctx.scale(2, 2);
        }

        const f = this.frame; 
        
        if (this.type === 0) { // Green Boss
            ctx.fillStyle = "#0f0";
            ctx.fillRect(-6, -8, 12, 10);
            ctx.fillRect(-10 + f*2, -2, 4, 8);
            ctx.fillRect(6 - f*2, -2, 4, 8);
            ctx.fillStyle = "#ff0";
            ctx.fillRect(-4, -4, 2, 2);
            ctx.fillRect(2, -4, 2, 2);
            ctx.fillStyle = "#f00";
            ctx.fillRect(-2, -10, 4, 2);
        } else if (this.type === 1) { // Red
            ctx.fillStyle = "#f00";
            ctx.beginPath();
            ctx.moveTo(0, 8);
            ctx.lineTo(-10 + f*2, -4);
            ctx.lineTo(-6, -8);
            ctx.lineTo(0, -2);
            ctx.lineTo(6, -8);
            ctx.lineTo(10 - f*2, -4);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.fillRect(-2, -4, 4, 8);
            ctx.fillStyle = "#00f";
            ctx.fillRect(-4, -6, 2, 2);
            ctx.fillRect(2, -6, 2, 2);
        } else { // Blue
            ctx.fillStyle = "#0af";
            ctx.beginPath();
            ctx.moveTo(0, 10);
            ctx.lineTo(-8 - f, -2);
            ctx.lineTo(-4, -8);
            ctx.lineTo(4, -8);
            ctx.lineTo(8 + f, -2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = "#ff0";
            ctx.fillRect(-4, -4, 2, 4);
            ctx.fillRect(2, -4, 2, 4);
        }

        ctx.restore();
    }
}


/**
 * Core Game Functions
 */

function initGame() {
    stars = [];
    for(let i=0; i<50; i++) {
        stars.push(new Star());
    }
    
    gameState.score = 0;
    gameState.lives = 5; // 초기화 시 5대
    gameState.level = 1;
    gameState.frames = 0;
    
    scoreEl.innerText = "00";
    
    startLevel();
    
    player = new Player();
    
    gameState.running = true;
    requestAnimationFrame(gameLoop);
}

function startLevel() {
    bullets = [];
    enemyBullets = [];
    particles = [];
    enemies = [];
    
    const startY = 80;
    const gapX = 70;
    const gapY = 60;
    const startX = canvas.width / 2 - 350; 
    
    for(let i=3; i<7; i++) {
         enemies.push(new Enemy(startX + i*gapX, startY, 0, i, 0));
    }
    for(let row=1; row<3; row++) {
        for(let i=1; i<9; i++) {
            enemies.push(new Enemy(startX + i*gapX, startY + row*gapY, 1, i, row));
        }
    }
    for(let row=3; row<5; row++) {
        for(let i=0; i<10; i++) {
            enemies.push(new Enemy(startX + i*gapX, startY + row*gapY, 2, i, row));
        }
    }
}

function createExplosion(x, y, color) {
    for(let i=0; i<10; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function checkCollisions() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        let hit = false;
        
        for (let j = enemies.length - 1; j >= 0; j--) {
            let e = enemies[j];
            if (rectCollision(b, e)) {
                let score = (e.type === 0) ? 150 : (e.type === 1) ? 80 : 50;
                if(e.state === 'diving') score *= 2; 
                
                addScore(score);
                createExplosion(e.x + e.width/2, e.y + e.height/2, e.type===0 ? '#0f0' : (e.type===1 ? '#f00' : '#0af'));
                SoundManager.playExplosion();
                
                enemies.splice(j, 1);
                hit = true;
                break;
            }
        }
        
        if (hit) {
            bullets.splice(i, 1);
        }
    }
    
    if (player.visible && player.invulnerable <= 0) {
        for (let eb of enemyBullets) {
            if (eb.active && rectCollision(eb, player)) {
                eb.active = false;
                player.explode();
                return;
            }
        }
        
        for (let e of enemies) {
            if (rectCollision(e, player)) {
                e.active = false; 
                createExplosion(e.x, e.y, "#fff");
                const index = enemies.indexOf(e);
                if(index > -1) enemies.splice(index, 1);
                
                player.explode();
                return;
            }
        }
    }
}

function addScore(points) {
    gameState.score += points;
    scoreEl.innerText = gameState.score.toString().padStart(6, '0');
    if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        highScoreEl.innerText = gameState.highScore;
    }
}

function endGame() {
    gameState.running = false;
    gameOverScreen.classList.remove('hidden');
    finalScoreEl.innerText = gameState.score;
}

function gameLoop() {
    if (!gameState.running) return;

    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    gameState.frames++;

    stars.forEach(star => {
        star.update();
        star.draw();
    });

    player.update();
    player.draw();

    bullets.forEach((b, index) => {
        b.update();
        b.draw();
        if (!b.active) bullets.splice(index, 1);
    });
    
    enemyBullets.forEach((b, index) => {
        b.update();
        b.draw();
        if (!b.active) enemyBullets.splice(index, 1);
    });

    if (enemies.length === 0) {
        gameState.level++;
        setTimeout(startLevel, 1000);
    }
    
    enemies.forEach(e => {
        e.update();
        e.draw();
    });

    particles.forEach((p, index) => {
        p.update();
        p.draw();
        if (p.life <= 0) particles.splice(index, 1);
    });

    // UI Lives (하단 여백 30px 추가하여 50px로 조정)
    for(let i=0; i<gameState.lives-1; i++) {
        ctx.fillStyle = "#eee";
        let lx = 10 + i * 25;
        let ly = canvas.height - 50; // 기존 20에서 50으로 변경 (30만큼 위로)
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.lineTo(lx+10, ly-10);
        ctx.lineTo(lx+20, ly);
        ctx.fill();
        ctx.fillStyle = "#d00";
        ctx.fillRect(lx+8, ly-4, 4, 4);
    }

    checkCollisions();

    requestAnimationFrame(gameLoop);
}


/**
 * Input Handling
 */
window.addEventListener('keydown', e => {
    if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
    if (e.code === 'ArrowRight') keys.ArrowRight = true;
    if (e.code === 'Space') {
        keys.Space = true;
        if(gameState.running) e.preventDefault(); 
    }
});

window.addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
    if (e.code === 'ArrowRight') keys.ArrowRight = false;
    if (e.code === 'Space') keys.Space = false;
});

// Touch & Drag Controls (Mobile)
canvas.addEventListener('touchstart', (e) => {
    if(!gameState.running) return;
    
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const tx = touch.clientX - rect.left;
    const ty = touch.clientY - rect.top;

    if (tx >= player.x - 50 && tx <= player.x + player.width + 50 &&
        ty >= player.y - 100 && ty <= player.y + player.height + 50) {
        
        isDragging = true;
        e.preventDefault(); 
    }
}, {passive: false});

canvas.addEventListener('touchmove', (e) => {
    if (!gameState.running || !isDragging) return;
    e.preventDefault();
    
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const tx = touch.clientX - rect.left;
    
    player.x = tx - player.width / 2;
    
    if (player.x < 10) player.x = 10;
    if (player.x > canvas.width - player.width - 10) player.x = canvas.width - player.width - 10;
    
}, {passive: false});

canvas.addEventListener('touchend', (e) => {
    isDragging = false;
});


// Button Listeners
document.getElementById('start-btn').addEventListener('click', () => {
    SoundManager.init();
    SoundManager.playStart();
    startScreen.classList.add('hidden');
    // 게임 시작 시 전체화면 시도
    toggleFullScreen();
    initGame();
});

document.getElementById('restart-btn').addEventListener('click', () => {
    SoundManager.init();
    SoundManager.playStart();
    gameOverScreen.classList.add('hidden');
    // 재시작 시에도 전체화면 시도
    toggleFullScreen();
    initGame();
});

// Initial Starfield (Attract Mode)
stars = [];
for(let i=0; i<50; i++) stars.push(new Star());
function attractLoop() {
    if (gameState.running) return;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    stars.forEach(star => {
        star.update();
        star.draw();
    });
    requestAnimationFrame(attractLoop);
}
attractLoop();

</script>
</body>
</html>