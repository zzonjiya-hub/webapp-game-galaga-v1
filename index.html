<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>갤러그 v1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            touch-action: none; /* 터치 스크롤 방지 */
        }
        
        /* 게임 컨테이너: 정사각형으로 제한될 영역 */
        #game-container {
            position: relative;
            /* width, height는 JS에서 정사각형으로 설정됨 */
            border: 2px solid #00ffff; /* 테두리 표시 */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2); /* 약간의 네온 효과 */
            background-color: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .header {
            padding: 15px; 
            display: flex;
            justify-content: space-between;
            font-size: 14px; 
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            width: 100%;
            box-sizing: border-box;
            z-index: 10;
            white-space: nowrap; /* 줄바꿈 방지 */
        }
        
        /* 텍스트가 겹치지 않도록 레이아웃 조정 */
        .header > div {
            display: flex;
            gap: 10px; /* 라벨과 점수 사이 간격 */
            align-items: center;
        }

        .score-box { color: #ff0000; }
        .high-score-box { color: #ffff00; }
        
        #fullscreen-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 14px;
            border-radius: 5px;
        }
        #fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.85);
            padding: 30px;
            border: 2px solid #fff;
            border-radius: 10px;
            width: 80%;
            max-width: 360px;
            z-index: 20;
        }

        button.action-btn {
            background: #f00;
            color: #fff;
            border: none;
            padding: 12px 20px;
            font-size: 18px;
            font-family: inherit;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            font-weight: bold;
            width: 100%;
        }
        button.action-btn:hover { background: #d00; }
        
        h1 { margin-top: 0; color: #00ffff; text-shadow: 3px 3px 0 #f00; font-size: 28px; }
        p { font-size: 13px; color: #ccc; line-height: 1.5; }
        .hidden { display: none !important; }
        
        /* 레벨 표시 강조 */
        .level-indicator {
            color: #00ffff;
            font-weight: bold;
        }
        .high-level-indicator {
            color: #ffff00; /* High Score와 같은 노란색 계열 */
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-layer">
            <div class="header">
                <!-- UI: 한 줄 표시 -->
                <div style="flex-direction: row;">
                    <div>PLAYER1</div>
                    <div>
                        <span id="score" style="color:white">00</span> 
                        <span id="current-level" class="level-indicator" style="margin-left:5px">Lv.1</span>
                    </div>
                </div>
                
                <!-- UI: 한 줄 표시, HI SCORE 00 초기화 -->
                <div style="flex-direction: row;">
                    <div class="high-score-box">HI SCORE</div>
                    <div>
                        <span id="high-score" style="color:white">00</span>
                        <span id="high-level" class="high-level-indicator" style="margin-left:5px">Lv.1</span>
                        <button id="fullscreen-btn" title="전체화면" style="margin-left:8px; padding: 2px 6px; font-size: 12px;">⛶</button>
                    </div>
                </div>
            </div>
            
            <div id="start-screen">
                <h1>KSMS GALAGA v1</h1>
                <p>PC: 방향키 이동 / SPACE 발사<br>
                   Touch/Mouse: 드래그 이동<br>
                   <span style="color:#0ff; font-size:11px;">(총 10단계 미션)</span></p>
                <button id="start-btn" class="action-btn">START GAME</button>
            </div>

            <div id="game-over-screen" class="hidden">
                <h1 id="game-result-title" style="color:red">GAME OVER</h1>
                <p>FINAL: <span id="final-score">0</span></p>
                <p>LEVEL REACHED: <span id="final-level" style="color:#0ff">1</span></p>
                <button id="restart-btn" class="action-btn">TRY AGAIN</button>
            </div>
        </div>
    </div>

<script>
/**
 * Sound Manager (Web Audio API)
 */
 const SoundManager = {
    ctx: null,
    
    init: function() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!this.ctx && AudioContext) {
            this.ctx = new AudioContext();
        }
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },

    playShoot: function() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.type = 'square';
        osc.frequency.setValueAtTime(880, t);
        osc.frequency.exponentialRampToValueAtTime(110, t + 0.15);

        gain.gain.setValueAtTime(0.025, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

        osc.start(t);
        osc.stop(t + 0.15);
    },

    // 적 폭발음
    playExplosion: function() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        
        const bufferSize = this.ctx.sampleRate * 0.4; 
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'lowpass';
        noiseFilter.frequency.setValueAtTime(1000, t);
        noiseFilter.frequency.exponentialRampToValueAtTime(50, t + 0.3); 

        const noiseGain = this.ctx.createGain();
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(this.ctx.destination);

        noiseGain.gain.setValueAtTime(0.3, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

        noise.start(t);
        noise.stop(t + 0.4);

        const osc = this.ctx.createOscillator();
        const oscGain = this.ctx.createGain();
        
        osc.connect(oscGain);
        oscGain.connect(this.ctx.destination);

        osc.type = 'triangle'; 
        osc.frequency.setValueAtTime(150, t); 
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.3); 

        oscGain.gain.setValueAtTime(0.5, t);
        oscGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

        osc.start(t);
        osc.stop(t + 0.4);
    },

    // 플레이어 전용 웅장한 폭발음
    playPlayerExplosion: function() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;

        const osc = this.ctx.createOscillator();
        const oscGain = this.ctx.createGain();
        osc.connect(oscGain);
        oscGain.connect(this.ctx.destination);

        osc.type = 'sawtooth'; 
        osc.frequency.setValueAtTime(200, t);
        osc.frequency.exponentialRampToValueAtTime(10, t + 1.2); 

        oscGain.gain.setValueAtTime(0.8, t); 
        oscGain.gain.exponentialRampToValueAtTime(0.01, t + 1.0); 

        osc.start(t);
        osc.stop(t + 1.2);

        const bufferSize = this.ctx.sampleRate * 1.5; 
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'lowpass';
        noiseFilter.frequency.setValueAtTime(3000, t); 
        noiseFilter.frequency.exponentialRampToValueAtTime(50, t + 1.0);

        const noiseGain = this.ctx.createGain();
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(this.ctx.destination);

        noiseGain.gain.setValueAtTime(1.0, t); 
        noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 1.0);

        noise.start(t);
        noise.stop(t + 1.2);
    },

    playStart: function() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.type = 'sine';
        osc.frequency.setValueAtTime(900, t);
        osc.frequency.setValueAtTime(1800, t + 0.1);

        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0.1, t + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);

        osc.start(t);
        osc.stop(t + 0.6);
    }
};

/**
 * Game Constants & Setup
 */
const gameContainer = document.getElementById('game-container');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highScoreEl = document.getElementById('high-score');
const currentLevelEl = document.getElementById('current-level');
const highLevelEl = document.getElementById('high-level'); 
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const gameResultTitle = document.getElementById('game-result-title');
const finalScoreEl = document.getElementById('final-score');
const finalLevelEl = document.getElementById('final-level');
const fullscreenBtn = document.getElementById('fullscreen-btn');

let gameState = {
    running: false,
    score: 0,
    highScore: 0,
    highScoreLevel: 1, 
    lives: 2, // **수정됨**: 초기 생명 2 (현재 1 + 예비 1)
    level: 1, 
    frames: 0,
    levelTransition: false 
};

const keys = {
    ArrowLeft: false,
    ArrowRight: false,
    ArrowUp: false,
    ArrowDown: false,
    Space: false
};

let isDragging = false;
let dragOffsetX = 0; 
let dragOffsetY = 0;

let player;
let bullets = [];
let enemyBullets = [];
let enemies = [];
let particles = [];
let stars = [];

/**
 * Utility Functions
 */
function rectCollision(rect1, rect2) {
    return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
    );
}

function resizeCanvas() {
    const size = Math.min(window.innerWidth, window.innerHeight);
    canvas.width = size;
    canvas.height = size;
    gameContainer.style.width = `${size}px`;
    gameContainer.style.height = `${size}px`;
    ctx.imageSmoothingEnabled = false;
}

function toggleFullScreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.log(`Error attempting to enable full-screen mode: ${err.message}`);
        });
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

function getCanvasCoords(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
    };
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas(); 

fullscreenBtn.addEventListener('click', toggleFullScreen);

/**
 * Classes
 */

class Star {
    constructor() {
        this.x = Math.random() * canvas.width; 
        this.y = Math.random() * canvas.height; 
        this.speed = Math.random() * 0.5 + 0.1;
        this.size = Math.random() * 1.5 + 0.5;
        this.color = Math.random() > 0.9 ? '#aaf' : '#555';
        if (Math.random() > 0.98) this.color = '#faa';
    }

    update() {
        this.y += (this.speed * (gameState.level * 0.5 + 1)); 
        if (this.y > canvas.height) {
            this.y = 0;
            this.x = Math.random() * canvas.width;
        }
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.life = 30;
        this.color = color;
        this.size = Math.random() * 3 + 1;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.size *= 0.9;
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 30;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

class Player {
    constructor() {
        this.width = 46; 
        this.height = 46;
        this.x = canvas.width / 2 - this.width / 2;
        this.y = canvas.height - this.height - 20; 
        
        this.speed = 5;
        this.cooldown = 0;
        this.invulnerable = 0;
        this.visible = true;
        
        this.topLimit = 0.4;
        this.bottomMargin = 20;
        this.sideMargin = 5;
    }
    
    getMinY() { return canvas.height * this.topLimit; }
    getMaxY() { return canvas.height - this.height - this.bottomMargin; }
    getMinX() { return this.sideMargin; }
    getMaxX() { return canvas.width - this.width - this.sideMargin; }

    update() {
        if (!this.visible) return;
        
        const minY = this.getMinY();
        const maxY = this.getMaxY();
        const minX = this.getMinX();
        const maxX = this.getMaxX();

        if (keys.ArrowLeft && this.x > minX) this.x -= this.speed;
        if (keys.ArrowRight && this.x < maxX) this.x += this.speed;
        if (keys.ArrowUp && this.y > minY) this.y -= this.speed;
        if (keys.ArrowDown && this.y < maxY) this.y += this.speed;
        
        if (this.x < minX) this.x = minX;
        if (this.x > maxX) this.x = maxX;
        if (this.y < minY) this.y = minY;
        if (this.y > maxY) this.y = maxY;

        if ((keys.Space || isDragging) && this.cooldown <= 0) {
            bullets.push(new Bullet(this.x + this.width / 2 - 3, this.y));
            this.cooldown = 10;
            SoundManager.playShoot();
        }
        if (this.cooldown > 0) this.cooldown--;
        if (this.invulnerable > 0) this.invulnerable--;
    }

    draw() {
        if (!this.visible) return;
        if (this.invulnerable > 0 && Math.floor(gameState.frames / 4) % 2 === 0) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        const scale = this.width / 30; 
        ctx.scale(scale, scale);
        
        ctx.fillStyle = "#eee";
        ctx.beginPath();
        ctx.moveTo(15, 0);
        ctx.lineTo(24, 18);
        ctx.lineTo(24, 24);
        ctx.lineTo(6, 24);
        ctx.lineTo(6, 18);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#d00";
        ctx.fillRect(13, 8, 4, 16);
        ctx.fillRect(2, 18, 4, 10);
        ctx.fillRect(24, 18, 4, 10);
        
        if (gameState.frames % 10 < 5) {
            ctx.fillStyle = "#fa0";
            ctx.fillRect(12, 26, 6, 4);
        }

        ctx.restore();
    }
    
    explode() {
        createExplosion(this.x + this.width/2, this.y + this.height/2, "#fff");
        SoundManager.playPlayerExplosion();
        this.visible = false;
        this.invulnerable = 180;
        
        isDragging = false; 
        
        setTimeout(() => {
            gameState.lives--;
            if(gameState.lives > 0) {
                this.x = canvas.width / 2 - this.width / 2;
                this.y = this.getMaxY();
                this.visible = true;
            } else {
                endGame();
            }
        }, 1000);
    }
    
    setPosition(targetX, targetY) {
        this.x = targetX - this.width / 2;
        this.y = targetY - this.height / 2;
        
        const minY = this.getMinY();
        const maxY = this.getMaxY();
        const minX = this.getMinX();
        const maxX = this.getMaxX();
        
        if (this.x < minX) this.x = minX;
        if (this.x > maxX) this.x = maxX;
        if (this.y < minY) this.y = minY;
        if (this.y > maxY) this.y = maxY;
    }
}

class Bullet {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 6;
        this.height = 15;
        this.speed = 10;
        this.active = true;
    }

    update() {
        this.y -= this.speed;
        if (this.y < 0) this.active = false;
    }

    draw() {
        ctx.fillStyle = "#ff0";
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.fillStyle = "#fff";
        ctx.fillRect(this.x + 1.5, this.y + 2, 3, 11);
    }
}

class EnemyBullet {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 10;
        this.height = 10;
        // **수정됨**: 적 탄속 2배 증가 (난이도 상승)
        // 기존: 3.0 + (level * 0.2)
        this.speed = 6.0 + (gameState.level * 0.4); 
        this.active = true;
    }
    
    update() {
        this.y += this.speed;
        if (this.y > canvas.height) this.active = false;
    }
    
    draw() {
        const radius = this.width / 2;
        const cx = this.x + radius;
        const cy = this.y + radius;

        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fillStyle = "#ff0";
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#f00";
        ctx.stroke();
    }
}

class Enemy {
    constructor(x, y, type, gridX, gridY, size) {
        this.x = x;
        this.y = y;
        this.originX = x;
        this.originY = y;
        this.gridX = gridX;
        this.gridY = gridY;
        this.type = type; 
        
        this.width = size;
        this.height = size;
        
        this.active = true;
        this.state = 'formation';
        this.vx = 0;
        this.vy = 0;
    }

    update() {
        if (this.state === 'formation') {
            const swayAmount = canvas.width * 0.08; 
            const sway = Math.sin(gameState.frames * 0.015) * swayAmount;
            this.x = this.originX + sway;
            
            // **수정됨**: 돌진 확률 2배 증가 (난이도 상승)
            // 기존: 0.0001 + (level * 0.0003)
            const diveChance = 0.0002 + (gameState.level * 0.0006);
            if (player.visible && Math.random() < diveChance) {
                this.startDive();
            }
        } else if (this.state === 'diving') {
            this.x += this.vx;
            this.y += this.vy;
            
            if (this.y < canvas.height / 2) {
                 if (this.x < player.x) this.vx += 0.05;
                 else this.vx -= 0.05;
            }

            // **수정됨**: 발사 확률 2배 증가 (난이도 상승)
            // 기존: 0.01 + (level * 0.002)
            const fireChance = 0.02 + (gameState.level * 0.004);
            if (Math.random() < fireChance && this.y < player.y - 100) {
                 enemyBullets.push(new EnemyBullet(this.x + this.width/2 - 5, this.y + this.height));
            }

            if (this.y > canvas.height + 20) {
                this.y = -60;
                this.state = 'returning';
                this.x = this.originX; 
                this.vx = 0;
                this.vy = 2;
            }
        } else if (this.state === 'returning') {
            const swayAmount = canvas.width * 0.08;
            const targetX = this.originX + (Math.sin(gameState.frames * 0.015) * swayAmount);
            const targetY = this.originY;
            
            const dx = targetX - this.x;
            const dy = targetY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < 5) {
                this.state = 'formation';
                this.y = targetY;
            } else {
                this.x += (dx / dist) * 4;
                this.y += (dy / dist) * 4;
            }
        }
        
        this.frame = Math.floor(gameState.frames / 40) % 2;
    }
    
    startDive() {
        this.state = 'diving';
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        this.vx = Math.cos(angle) * 2; 
        this.vy = Math.sin(angle) * 2 + 1;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        
        const scale = this.width / 24; 
        if (this.state === 'diving') {
            ctx.scale(scale * 1.5, -scale * 1.5);
        } else {
            ctx.scale(scale * 1.5, scale * 1.5);
        }

        const f = this.frame; 
        
        if (this.type === 0) { // Green Boss
            ctx.fillStyle = "#0f0";
            ctx.fillRect(-6, -8, 12, 10);
            ctx.fillRect(-10 + f*2, -2, 4, 8);
            ctx.fillRect(6 - f*2, -2, 4, 8);
            ctx.fillStyle = "#ff0";
            ctx.fillRect(-4, -4, 2, 2);
            ctx.fillRect(2, -4, 2, 2);
            ctx.fillStyle = "#f00";
            ctx.fillRect(-2, -10, 4, 2);
        } else if (this.type === 1) { // Red
            ctx.fillStyle = "#f00";
            ctx.beginPath();
            ctx.moveTo(0, 8);
            ctx.lineTo(-10 + f*2, -4);
            ctx.lineTo(-6, -8);
            ctx.lineTo(0, -2);
            ctx.lineTo(6, -8);
            ctx.lineTo(10 - f*2, -4);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.fillRect(-2, -4, 4, 8);
            ctx.fillStyle = "#00f";
            ctx.fillRect(-4, -6, 2, 2);
            ctx.fillRect(2, -6, 2, 2);
        } else { // Blue
            ctx.fillStyle = "#0af";
            ctx.beginPath();
            ctx.moveTo(0, 10);
            ctx.lineTo(-8 - f, -2);
            ctx.lineTo(-4, -8);
            ctx.lineTo(4, -8);
            ctx.lineTo(8 + f, -2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = "#ff0";
            ctx.fillRect(-4, -4, 2, 4);
            ctx.fillRect(2, -4, 2, 4);
        }

        ctx.restore();
    }
}


/**
 * Core Game Functions
 */

function initGame() {
    stars = [];
    for(let i=0; i<50; i++) {
        stars.push(new Star());
    }
    
    gameState.score = 0;
    gameState.lives = 2; // **수정됨**: 총 2대 (사용중 1 + 예비 1)
    gameState.level = 1; 
    gameState.frames = 0;
    gameState.levelTransition = false;
    
    scoreEl.innerText = "00";
    currentLevelEl.innerText = "Lv.1";
    
    startLevel();
    
    player = new Player();
    
    gameState.running = true;
    requestAnimationFrame(gameLoop);
}

function startLevel() {
    bullets = [];
    enemyBullets = [];
    particles = [];
    enemies = [];
    
    const baseSize = 36; 
    const enemySize = Math.min(baseSize, canvas.width / 12); 
    
    const gapX = enemySize * 1.4; 
    const gapY = enemySize * 1.2; 
    
    const totalEnemiesWidth = (9 * gapX);
    const startX = (canvas.width - totalEnemiesWidth) / 2;
    const startY = canvas.height * 0.1; 
    
    for(let i=3; i<7; i++) { // Boss
         enemies.push(new Enemy(startX + i*gapX, startY, 0, i, 0, enemySize));
    }
    for(let row=1; row<3; row++) { // Red
        for(let i=1; i<9; i++) {
            enemies.push(new Enemy(startX + i*gapX, startY + row*gapY, 1, i, row, enemySize));
        }
    }
    for(let row=3; row<5; row++) { // Blue
        for(let i=0; i<10; i++) {
            enemies.push(new Enemy(startX + i*gapX, startY + row*gapY, 2, i, row, enemySize));
        }
    }
}

function createExplosion(x, y, color) {
    for(let i=0; i<10; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function checkCollisions() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        let hit = false;
        
        for (let j = enemies.length - 1; j >= 0; j--) {
            let e = enemies[j];
            if (rectCollision(b, e)) {
                let score = 10; 
                
                addScore(score);
                createExplosion(e.x + e.width/2, e.y + e.height/2, e.type===0 ? '#0f0' : (e.type===1 ? '#f00' : '#0af'));
                SoundManager.playExplosion();
                
                enemies.splice(j, 1);
                hit = true;
                break;
            }
        }
        
        if (hit) {
            bullets.splice(i, 1);
        }
    }
    
    if (player.visible && player.invulnerable <= 0) {
        for (let eb of enemyBullets) {
            if (eb.active && rectCollision(eb, player)) {
                eb.active = false;
                player.explode();
                return;
            }
        }
        
        for (let e of enemies) {
            if (rectCollision(e, player)) {
                e.active = false; 
                createExplosion(e.x, e.y, "#fff");
                const index = enemies.indexOf(e);
                if(index > -1) enemies.splice(index, 1);
                
                player.explode();
                return;
            }
        }
    }
}

function addScore(points) {
    gameState.score += points;
    scoreEl.innerText = gameState.score === 0 ? "00" : gameState.score.toString();
    
    if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        highScoreEl.innerText = gameState.highScore === 0 ? "00" : gameState.highScore.toString();
        
        gameState.highScoreLevel = gameState.level;
        highLevelEl.innerText = `Lv.${gameState.highScoreLevel}`;
    }
}

function endGame() {
    gameState.running = false;
    gameOverScreen.classList.remove('hidden');
    // UI 복원 (게임 오버 시)
    gameResultTitle.innerText = "GAME OVER";
    gameResultTitle.style.color = "red";
    finalScoreEl.innerText = gameState.score;
    finalLevelEl.innerText = gameState.level;
}

// **추가됨**: 게임 클리어 함수
function gameClear() {
    gameState.running = false;
    gameOverScreen.classList.remove('hidden');
    // 축하 메시지로 변경
    gameResultTitle.innerText = "MISSION COMPLETE!";
    gameResultTitle.style.color = "#00ffff"; // 시안색으로 승리 강조
    finalScoreEl.innerText = gameState.score;
    finalLevelEl.innerText = "10 (MAX)";
    
    SoundManager.playStart(); // 승리 효과음으로 시작음 재사용
}

function gameLoop() {
    if (!gameState.running) return;

    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    gameState.frames++;

    stars.forEach(star => {
        star.update();
        star.draw();
    });

    player.update();
    player.draw();

    bullets.forEach((b, index) => {
        b.update();
        b.draw();
        if (!b.active) bullets.splice(index, 1);
    });
    
    enemyBullets.forEach((b, index) => {
        b.update();
        b.draw();
        if (!b.active) enemyBullets.splice(index, 1);
    });

    // 레벨 클리어 / 게임 클리어 로직
    if (enemies.length === 0 && !gameState.levelTransition) {
        gameState.levelTransition = true; 
        
        setTimeout(() => {
            // **수정됨**: 레벨 10 클리어 시 게임 종료
            if (gameState.level >= 10) {
                gameClear();
                return;
            }

            gameState.level++; // 레벨 증가
            currentLevelEl.innerText = `Lv.${gameState.level}`; 
            
            if (gameState.score >= gameState.highScore) {
                gameState.highScoreLevel = gameState.level;
                highLevelEl.innerText = `Lv.${gameState.highScoreLevel}`;
            }

            startLevel(); // 다음 레벨 적 생성
            gameState.levelTransition = false; 
        }, 1500);
    }
    
    enemies.forEach(e => {
        e.update();
        e.draw();
    });

    particles.forEach((p, index) => {
        p.update();
        p.draw();
        if (p.life <= 0) particles.splice(index, 1);
    });

    for(let i=0; i<gameState.lives-1; i++) {
        ctx.fillStyle = "#eee";
        let lx = 10 + i * 25;
        let ly = canvas.height - 30; 
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.lineTo(lx+10, ly-10);
        ctx.lineTo(lx+20, ly);
        ctx.fill();
        ctx.fillStyle = "#d00";
        ctx.fillRect(lx+8, ly-4, 4, 4);
    }

    checkCollisions();

    requestAnimationFrame(gameLoop);
}


/**
 * Input Handling
 */
window.addEventListener('keydown', e => {
    if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
    if (e.code === 'ArrowRight') keys.ArrowRight = true;
    if (e.code === 'ArrowUp') { keys.ArrowUp = true; if(gameState.running) e.preventDefault(); }
    if (e.code === 'ArrowDown') { keys.ArrowDown = true; if(gameState.running) e.preventDefault(); }
    if (e.code === 'Space') { keys.Space = true; if(gameState.running) e.preventDefault(); }
});

window.addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
    if (e.code === 'ArrowRight') keys.ArrowRight = false;
    if (e.code === 'ArrowUp') keys.ArrowUp = false;
    if (e.code === 'ArrowDown') keys.ArrowDown = false;
    if (e.code === 'Space') keys.Space = false;
});


const handleStart = (clientX, clientY) => {
    if (!gameState.running || !player || !player.visible) return;
    const coords = getCanvasCoords(clientX, clientY);
    
    const hitPadding = 100;
    if (coords.x >= player.x - hitPadding && 
        coords.x <= player.x + player.width + hitPadding &&
        coords.y >= player.y - hitPadding && 
        coords.y <= player.y + player.height + hitPadding) {
        
        isDragging = true;
        dragOffsetX = coords.x - (player.x + player.width / 2);
        dragOffsetY = coords.y - (player.y + player.height / 2);
    }
};

const handleMove = (clientX, clientY) => {
    if (!gameState.running || !isDragging || !player || !player.visible) return;
    const coords = getCanvasCoords(clientX, clientY);
    player.setPosition(coords.x - dragOffsetX, coords.y - dragOffsetY);
};

const handleEnd = () => { isDragging = false; };

canvas.addEventListener('mousedown', e => { handleStart(e.clientX, e.clientY); e.preventDefault(); });
canvas.addEventListener('mousemove', e => { handleMove(e.clientX, e.clientY); e.preventDefault(); });
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('mouseleave', handleEnd);

canvas.addEventListener('touchstart', e => { handleStart(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); }, {passive: false});
canvas.addEventListener('touchmove', e => { handleMove(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); }, {passive: false});
canvas.addEventListener('touchend', handleEnd);
canvas.addEventListener('touchcancel', handleEnd);


document.getElementById('start-btn').addEventListener('click', () => {
    SoundManager.init();
    SoundManager.playStart();
    startScreen.classList.add('hidden');
    initGame();
});

document.getElementById('restart-btn').addEventListener('click', () => {
    SoundManager.init();
    SoundManager.playStart();
    gameOverScreen.classList.add('hidden');
    initGame();
});

stars = [];
for(let i=0; i<50; i++) stars.push(new Star());
function attractLoop() {
    if (gameState.running) return;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    stars.forEach(star => {
        star.update();
        star.draw();
    });
    requestAnimationFrame(attractLoop);
}
attractLoop();

</script>
</body>
</html>